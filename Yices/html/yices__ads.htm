<HEAD><TITLE>yices.ads</TITLE></HEAD>
<BODY>
<HR><DIV ALIGN="center"><H1> File : yices.ads </H1></DIV><HR>
<PRE>
<b>with</b> Interfaces.C, Interfaces.C.Strings;
<b>with</b> Ada.Unchecked_Conversion;
<b>with</b> System;

<b>package</b> Yices <b>is</b>
   
   <b>pragma</b> Preelaborate ;
   
   <FONT COLOR=green><EM>--------------</EM></FONT>
   <FONT COLOR=green><EM>-- Typedefs --</EM></FONT>
   <FONT COLOR=green><EM>--------------</EM></FONT>
   
   <FONT COLOR=green><EM>-- Yices context </EM></FONT>
   <b>type</b> Yices_Context <b>is</b> <b>new</b> System.Address ;
   
   <FONT COLOR=green><EM>-- Yices types (abstract syntax tree). </EM></FONT>
   <b>type</b> Yices_Type <b>is</b> <b>new</b> System.Address ;
   
   <b>type</b> Yices_Type_Array <b>is</b> <b>array</b>(Integer <b>range</b> &lt;&gt;) <b>of</b> Yices_Type ;
   <b>pragma</b> Convention(C,Yices_Type_Array) ;
   <FONT COLOR=green><EM>--for Yices_Type_Array'Component_size use Yices_Type'Size ;</EM></FONT>
   
   <FONT COLOR=green><EM>-- Yices expressions (abstract syntax tree). </EM></FONT>
   <b>type</b> Yices_Expr <b>is</b> <b>new</b> System.Address ;
   
   <b>type</b> Yices_Expr_Array <b>is</b> <b>array</b>(Integer <b>range</b> &lt;&gt;) <b>of</b> Yices_Expr ;
   <b>pragma</b> Convention(C,Yices_Expr_Array) ;
   <FONT COLOR=green><EM>--for Yices_Expr_Array'Component_size use System.Address'Size ;</EM></FONT>
      
   <FONT COLOR=green><EM>-- Variable declaration. </EM></FONT>
   <b>type</b> Yices_Var_Decl <b>is</b> <b>new</b> System.Address ;

   <FONT COLOR=green><EM>-- Assertion index, to identify weighted and retractable assertions.  </EM></FONT>
   <b>subtype</b> Assertion_Id <b>is</b> Interfaces.C.Int ;
   
   <b>type</b> Assertion_Id_Array <b>is</b> <b>array</b>(Integer <b>range</b> &lt;&gt;) <b>of</b> Assertion_Id ;
   <b>pragma</b> Convention(C,Assertion_Id_Array) ;
   <b>for</b> Assertion_Id_Array'Component_size <b>use</b> Interfaces.C.Int'Size ;

   <FONT COLOR=green><EM>-- Model</EM></FONT>
   <b>type</b> Yices_Model <b>is</b> <b>new</b> System.Address ;
   
   <FONT COLOR=green><EM>--Iterator for scanning the boolean variables. </EM></FONT>
   <b>type</b> Yices_Var_Decl_Iterator <b>is</b> <b>new</b> System.Address ;

   <FONT COLOR=green><EM>-- Extended booleans: to represent the value of literals in the context</EM></FONT>
   <b>type</b> Lbool <b>is</b>
     ( L_False ,
       L_Undef ,
       L_True ) ;
   
   <b>for</b> Lbool <b>use</b>
     ( L_False =&gt; -1 ,
       L_Undef =&gt; 0,
       L_True =&gt; 1 );
   
   <b>pragma</b> Convention(C,Lbool);
   
   <FONT COLOR=green><EM>-- String allocation structure used by:</EM></FONT>
   <FONT COLOR=green><EM>-- * yices_get_arith_value_as_string </EM></FONT>
   <FONT COLOR=green><EM>-- * yices_free_string.</EM></FONT>
   <b>type</b> Srec_T <b>is</b> <b>record</b>
      Flag : Interfaces.C.Int ;
      Str : Interfaces.C.Strings.Chars_Ptr ;
   <b>end</b> <b>record</b>;
   
   <b>pragma</b> Convention(C,Srec_T) ;
   
   <b>type</b> Srec_T_Access <b>is</b> <b>access</b> <b>all</b> Srec_T ;
   
   <b>type</b> Bv_Array <b>is</b> <b>array</b>(Integer <b>range</b> &lt;&gt;) <b>of</b> Interfaces.C.Int ;
   <b>pragma</b> Convention(C,Bv_Array) ;
   <b>for</b> Bv_Array'Component_Size <b>use</b> Interfaces.C.int'Size;
   
   <FONT COLOR=green><EM>---------------</EM></FONT>
   <FONT COLOR=green><EM>-- Functions --</EM></FONT>
   <FONT COLOR=green><EM>---------------</EM></FONT>
   
   <FONT COLOR=green><EM>-- Return the yices version number. </EM></FONT>
   <b>function</b> Yices_Version <b>return</b> Interfaces.C.Strings.Chars_Ptr ;
   <b>pragma</b> Import(C,Yices_Version,"yices_version") ;
   
   <FONT COLOR=green><EM>-- Set the verbosity level. </EM></FONT>
   <b>procedure</b> Yices_Set_Verbosity( L : <b>in</b> Interfaces.C.Int ) ;
   <b>pragma</b> Import(C,Yices_Set_Verbosity,"yices_set_verbosity") ;

   <FONT COLOR=green><EM>-- Force Yices to type check expressions when they are asserted (default = false). </EM></FONT>
   <b>procedure</b> Yices_Enable_Type_Checker( Flag : <b>in</b> Interfaces.C.Int ) ;
   <b>pragma</b> Import(C,Yices_Enable_Type_Checker,"yices_enable_type_checker") ;

   <FONT COLOR=green><EM>-- Enable a log file that will store the assertions, checks, declartationss, etc. </EM></FONT>
   <b>function</b> Yices_Enable_Log_File( File_Name : <b>in</b> Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Enable_Log_File,"yices_enable_log_file") ;
   
   <FONT COLOR=green><EM>-- Inform Yices that only the arithmetic theory is going to be used.</EM></FONT>
   <b>procedure</b> Yices_Set_Arith_Only( Flag : <b>in</b> Interfaces.C.Int ) ;
   <b>pragma</b> Import(C,Yices_Set_Arith_Only,"yices_set_arith_only") ;
   
   <FONT COLOR=green><EM>-- Set the maximum number of conflicts that are allowed in a maxsat iteration. </EM></FONT>
   <b>procedure</b> Yices_Set_Max_Num_Conflicts_In_Maxsat_Iteration( N : <b>in</b> Interfaces.C.Unsigned ) ;
   <b>pragma</b> Import(C,Yices_Set_Max_Num_Conflicts_In_Maxsat_Iteration,"yices_set_max_num_conflicts_in_maxsat_iteration") ;
   
   <FONT COLOR=green><EM>-- Set the maximum number of iterations in the MaxSAT algorithm. </EM></FONT>
   <b>procedure</b> Yices_Set_Max_Num_Iterations_In_Maxsat( N : <b>in</b> Interfaces.C.Unsigned ) ;
   <b>pragma</b> Import(C,Yices_Set_Max_Num_Iterations_In_Maxsat,"yices_set_max_num_iterations_in_maxsat") ;

   <FONT COLOR=green><EM>-- Set the initial cost for a maxsat problem. </EM></FONT>
   <b>procedure</b> Yices_Set_Maxsat_Initial_Cost( C : <b>in</b> Long_Long_Integer ) ;
   <b>pragma</b> Import(C,Yices_Set_Maxsat_Initial_Cost,"yices_set_maxsat_initial_cost") ;
   
   <FONT COLOR=green><EM>-- Create the logical context. </EM></FONT>
   <b>function</b> Yices_Mk_Context <b>return</b> Yices_Context ;
   <b>pragma</b> Import(C,Yices_Mk_Context,"yices_mk_context") ;
   
   <FONT COLOR=green><EM>-- Delete the logical context. </EM></FONT>
   <b>procedure</b> Yices_Del_Context( Ctx : <b>in</b> Yices_Context ) ;
   <b>pragma</b> Import(C,Yices_Del_Context,"yices_del_context") ;
   
   <FONT COLOR=green><EM>-- Reset the logical context. </EM></FONT>
   <b>procedure</b> Yices_Reset( Ctx : <b>in</b> Yices_Context ) ;
   <b>pragma</b> Import(C,Yices_Reset,"yices_reset") ;
   
   <FONT COLOR=green><EM>-- Display the internal representation of the logical context on stderr. </EM></FONT>
   <b>procedure</b> Yices_Dump_Context( Ctx : <b>in</b> Yices_Context ) ;
   <b>pragma</b> Import(C,Yices_Dump_Context,"yices_dump_context") ;
   
   <FONT COLOR=green><EM>-- Create a backtracking point. </EM></FONT>
   <b>procedure</b> Yices_Push( Ctx : <b>in</b> Yices_Context ) ;
   <b>pragma</b> Import(C,Yices_Push,"yices_push") ;
   
   <FONT COLOR=green><EM>-- Backtrack. </EM></FONT>
   <b>procedure</b> Yices_Pop( Ctx : <b>in</b> Yices_Context ) ;
   <b>pragma</b> Import(C,Yices_Pop,"yices_pop") ;
   
   <FONT COLOR=green><EM>-- Assert a constraint in the logical context. </EM></FONT>
   <b>procedure</b> Yices_Assert( Ctx : <b>in</b> Yices_Context ; Expr : <b>in</b> Yices_Expr ) ;
   <b>pragma</b> Import(C,Yices_Assert,"yices_assert") ;
   
   <FONT COLOR=green><EM>-- Assert a constraint in the logical context with weight w.</EM></FONT>
   <b>function</b> Yices_Assert_Weighted( Ctx : <b>in</b> Yices_Context ; Expr : <b>in</b> Yices_Expr ; W : <b>in</b> Long_Long_Integer ) <b>return</b> Assertion_Id ;
   <b>pragma</b> Import(C,Yices_Assert_Weighted,"yices_assert_weighted") ;
   
   <FONT COLOR=green><EM>-- Assert a constraint that can be later retracted. </EM></FONT>
   <b>function</b> Yices_Assert_Retractable( Ctx : <b>in</b> Yices_Context ; Expr : <b>in</b> Yices_Expr ) <b>return</b> Assertion_Id ;
   <b>pragma</b> Import(C,Yices_Assert_Retractable,"yices_assert_retractable") ;
   
   <FONT COLOR=green><EM>-- Retract a retractable or weighted constraint. </EM></FONT>
   <b>procedure</b> Yices_Retract( Ctx : <b>in</b> Yices_Context ; Id : <b>in</b> Assertion_Id ) ;
   <b>pragma</b> Import(C,Yices_Retract,"yices_retract") ;
   
   <FONT COLOR=green><EM>-- Check whether the logical context is known to be inconsistent. </EM></FONT>
   <b>function</b> Yices_Inconsistent( Ctx : <b>in</b> Yices_Context ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Inconsistent,"yices_inconsistent") ;
   
   <FONT COLOR=green><EM>-- Check if the logical context is satisfiable. </EM></FONT>
   <b>function</b> Yices_Check( Ctx : <b>in</b> Yices_Context ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Check,"yices_check") ;
   
   <FONT COLOR=green><EM>-- Compute the maximal satisfying assignment for the asserted weighted constraints. </EM></FONT>
   <b>function</b> Yices_Max_Sat( Ctx : <b>in</b> Yices_Context ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Max_Sat,"yices_max_sat") ;
   
   <FONT COLOR=green><EM>-- Similar to yices_max_sat, but start looking for models with cost less than of equal to max_cost. </EM></FONT>
   <b>function</b> Yices_Max_Sat_Cost_Leq( C : <b>in</b> Yices_Context ; Max_Cost : Long_Long_Integer ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Max_Sat_Cost_Leq,"yices_max_sat_cost_leq") ;
   
   <FONT COLOR=green><EM>-- Search for a model of the constraints asserted in ctx and compute its cost. </EM></FONT>
   <b>function</b> Yices_Find_Weighted_Model( Ctx : <b>in</b> Yices_Context ; Random : Interfaces.C.Int ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Find_Weighted_Model,"yices_find_weighted_model") ;
   
   <FONT COLOR=green><EM>-- Return the size of the unsatisfiable core.</EM></FONT>
   <b>function</b> Yices_Get_Unsat_Core_Size( Ctx : <b>in</b> Yices_Context ) <b>return</b> Interfaces.C.Unsigned ;
   <b>pragma</b> Import(C,Yices_Get_Unsat_Core_Size,"yices_get_unsat_core_size") ;
   
   <FONT COLOR=green><EM>-- Return the unsatisfiable core. </EM></FONT>
   <b>function</b> Yices_Get_Unsar_Core( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Assertion_Id_Array ) <b>return</b> Interfaces.C.Unsigned ;
   <b>pragma</b> Import(C,Yices_Get_Unsar_Core,"yices_get_unsat_core") ;
   
   <FONT COLOR=green><EM>-- Return a model for a satisfiable context. </EM></FONT>
   <b>function</b> Yices_Get_Model( Ctx : <b>in</b> Yices_Context ) <b>return</b> Yices_Model ;
   <b>pragma</b> Import(C,Yices_Get_Model,"yices_get_model") ;
   
   <FONT COLOR=green><EM>-- Return the value of variable v in model m. </EM></FONT>
   <b>function</b> Yices_Get_Value( M : <b>in</b> Yices_Model ; V : <b>out</b> Yices_Var_Decl ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Get_Value,"yices_get_value") ;
   
   <FONT COLOR=green><EM>-- Get the integer value assigned to variable v in model m. </EM></FONT>
   <b>function</b> Yices_Get_Int_Value( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ; Value : <b>access</b> Interfaces.C.Long ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Int_Value,"yices_get_int_value") ;
   
   <FONT COLOR=green><EM>-- Get the rational value assigned to variable v in model m.</EM></FONT>
   <b>function</b> Yices_Get_Arith_Value( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ; Num, Den : <b>access</b> Interfaces.C.Long ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Arith_Value,"yices_get_arith_value") ;
   
   <FONT COLOR=green><EM>-- Convert the value assigned to variable v in model m to a floating poin number. </EM></FONT>
   <b>function</b> Yices_Get_Double_Value( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ; Value : <b>access</b> Long_Float) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Double_Value,"yices_get_double_value") ;
   
   <FONT COLOR=green><EM>-- Convert the value assigned to variable v in model m to a GMP rational (mpq_t). </EM></FONT>
   <FONT COLOR=green><EM>--  int 	yices_get_mpq_value (yices_model m, yices_var_decl d, mpq_t value)</EM></FONT>
   
   <FONT COLOR=green><EM>-- Convert the value assigned to variable v in model m to a GMP integer (mpz_t). </EM></FONT>
   <FONT COLOR=green><EM>--  int 	yices_get_mpz_value (yices_model m, yices_var_decl d, mpz_t value)</EM></FONT>
   
   <FONT COLOR=green><EM>-- Get the value assigned to variable v in model m as a string. </EM></FONT>
   <b>function</b> Yices_Get_Arith_Value_As_String( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ; R : Srec_T_Access ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Arith_Value_As_String,"yices_get_arith_value_as_string") ;
   
   <FONT COLOR=green><EM>-- Free a string allocated by Yices</EM></FONT>
   <b>function</b> Yices_Free_String( R : Srec_T_Access ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Free_String,"yices_free_string") ;
   
   <FONT COLOR=green><EM>-- Get the bitvector constant assigned to a variable v in model m. </EM></FONT>
   <b>function</b> Yices_Get_Bitvector_Value( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ; N : <b>in</b> Interfaces.C.Unsigned ; Bv : Bv_Array ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Bitvector_Value,"yices_get_bitvector_value") ;
   
   <FONT COLOR=green><EM>-- Get the value assigned to a scalar variable v in model m. </EM></FONT>
   <b>function</b> Yices_Get_Scalar_Value( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Scalar_Value,"yices_get_scalar_value") ;
   
   <FONT COLOR=green><EM>-- Get the value assigned to a scalar variable v in model m. </EM></FONT>
   <b>function</b> Yices_Get_Scalar_Value_Name( M : <b>in</b> Yices_Model ; D : <b>in</b> Yices_Var_Decl ) <b>return</b> Interfaces.C.Strings.Chars_Ptr ;
   <b>pragma</b> Import(C,Yices_Get_Scalar_Value_Name,"yices_get_scalar_value_name") ;
   
   <FONT COLOR=green><EM>-- Return 1 (0) if the assertion of the given id is satisfied (not satisfied) in the model m. </EM></FONT>
   <b>function</b> Yices_Get_Assertion_Value( M : <b>in</b> Yices_Model ; Id : <b>in</b> Assertion_Id ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Get_Assertion_Value,"yices_get_assertion_value") ;
   
   <FONT COLOR=green><EM>-- Evaluate a formula in a model. </EM></FONT>
   <b>function</b> Yices_Evaluate_In_Model( M : <b>in</b> Yices_Model ; E : <b>in</b> Yices_Expr ) <b>return</b> Lbool ;
   <b>pragma</b> Import(C,Yices_Evaluate_In_Model,"yices_evaluate_in_model") ;
   
   <FONT COLOR=green><EM>-- Display the given model in the standard output. </EM></FONT>
   <b>procedure</b> Yices_Display_Model( M : <b>in</b> Yices_Model ) ;
   <b>pragma</b> Import(C,Yices_Display_Model,"yices_display_model") ;
   
   <FONT COLOR=green><EM>-- Return the cost of model m. </EM></FONT>
   <b>function</b> Yices_Get_Cost( M : <b>in</b> Yices_Model ) <b>return</b> Long_Long_Integer ;
   <b>pragma</b> Import(C,Yices_Get_Cost,"yices_get_cost") ;
   
   <FONT COLOR=green><EM>-- Return the cost of the model m, converted to a double-precision floating point number. </EM></FONT>
   <b>function</b> Yices_Get_Cost_As_Double( M : <b>in</b> Yices_Model ) <b>return</b> Interfaces.C.Double ;
   <b>pragma</b> Import(C,Yices_Get_Cost_As_Double,"yices_get_cost_as_double") ;
   
   <FONT COLOR=green><EM>-- Create an iterator that can be used to traverse the boolean variables (var_decl objects) in the logical context. </EM></FONT>
   <b>function</b> Yices_Create_Var_Decl_Iterator( C : <b>in</b> Yices_Context ) <b>return</b> Yices_Var_Decl_Iterator ;
   <b>pragma</b> Import(C,Yices_Create_Var_Decl_Iterator,"yices_create_var_decl_iterator") ;
   
   <FONT COLOR=green><EM>-- Return 1 if the iterator it still has elements to be iterated. Return 0 otherwise. </EM></FONT>
   <b>function</b> Yices_Iterator_Has_Next( It : <b>in</b> Yices_Var_Decl_Iterator) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Iterator_Has_Next,"yices_iterator_has_next") ;
   
   <FONT COLOR=green><EM>-- Return the next variable, and move the iterator. </EM></FONT>
   <b>function</b> Yices_Iterator_Next( It : <b>in</b> Yices_Var_Decl_Iterator ) <b>return</b> Yices_Var_Decl ;
   <b>pragma</b> Import(C,Yices_Iterator_Next,"yices_iterator_next") ;
   
   <FONT COLOR=green><EM>-- Reset the given iterator, that is, move it back to the first element. </EM></FONT>
   <b>procedure</b> Yices_Iterator_Reset( It : <b>in</b> Yices_Var_Decl_Iterator ) ;
   <b>pragma</b> Import(C,Yices_Iterator_Reset,"yices_iterator_reset") ;
   
   <FONT COLOR=green><EM>-- Delete an iterator created with yices_create_var_decl_iterator. </EM></FONT>
   <b>procedure</b> Yices_Del_Iterator( It : <b>in</b> Yices_Var_Decl_Iterator ) ;
   <b>pragma</b> Import(C,Yices_Del_Iterator,"yices_del_iterator") ;
   
   <FONT COLOR=green><EM>-- Parse string s as an expression in the Yices syntax. </EM></FONT>
   <b>function</b> Yices_Parse_Expression( Ctx : <b>in</b> Yices_Context ; S : Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Parse_Expression,"yices_parse_expression") ;
   
   <FONT COLOR=green><EM>-- Parse string s as a type in the Yices syntax. </EM></FONT>
   <b>function</b> Yices_Parse_Type( Ctx : <b>in</b> Yices_Context ; S : Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Type ;
   <b>pragma</b> Import(C,Yices_Parse_Type,"yices_parse_type") ;
   
   <FONT COLOR=green><EM>-- Parse string s as a command in the Yices syntax and execute the command. </EM></FONT>
   <b>function</b> Yices_Parse_Command( Ctx : <b>in</b> Yices_Context ; S : Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Interfaces.C.Int ;
   <b>pragma</b> Import(C,Yices_Parse_Command,"yices_parse_command") ;
   
   <FONT COLOR=green><EM>-- Return the last error message. </EM></FONT>
   <b>function</b> Yices_Get_Last_Error_Message <b>return</b> Interfaces.C.Strings.Chars_Ptr ;
   <b>pragma</b> Import(C,Yices_Get_Last_Error_Message,"yices_get_last_error_message") ;
   
   <FONT COLOR=green><EM>-- Return the type associated with the given name. If the type does not exist, a new uninterpreted type is created. </EM></FONT>
   <b>function</b> Yices_Mk_Type( Ctx : <b>in</b> Yices_Context ; Name : Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Type ;
   <b>pragma</b> Import(C,Yices_Mk_Type,"yices_mk_type") ;
   
   <FONT COLOR=green><EM>-- Returns the bitvector type (bv[size]). </EM></FONT>
   <b>function</b> Yices_Mk_Bitvector_Type( Ctx : <b>in</b> Yices_Context ; Size : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Type ;
   <b>pragma</b> Import(C,Yices_Mk_Bitvector_Type,"yices_mk_bitvector_type") ;
   
   <FONT COLOR=green><EM>-- Return a function type (-&gt; d1 ... dn r). </EM></FONT>
   <b>function</b> Yices_Mk_Function_Type( Ctx : <b>in</b> Yices_Context ; Domain : <b>in</b> Yices_Type_Array ; Domain_Size : <b>in</b> Interfaces.C.Unsigned ; R : <b>in</b> Yices_Type ) <b>return</b> Yices_Type ;
   <b>pragma</b> Import(C,Yices_Mk_Function_Type,"yices_mk_function_type") ;
   
   <FONT COLOR=green><EM>-- Constructs the tuple type (arg[0], ..., arg[size-1]). </EM></FONT>
   <b>function</b> Yices_Mk_Tuple_Type( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Type_Array ; Size : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Type ;
   <b>pragma</b> Import(C,Yices_Mk_Tuple_Type,"yices_mk_tuple_type") ;
   
   <FONT COLOR=green><EM>-- Return a new boolean variable declaration. </EM></FONT>
   <b>function</b> Yices_Mk_Bool_Var_Decl( Ctx : <b>in</b> Yices_Context ; Name : Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Var_Decl ;
   <b>pragma</b> Import(C,Yices_Mk_Bool_Var_Decl,"yices_mk_bool_var_decl") ;
   
   <FONT COLOR=green><EM>-- Return a new (global) variable declaration. It is an error to create two variables with the same name. </EM></FONT>
   <b>function</b> Yices_Mk_Var_Decl( Ctx : <b>in</b> Yices_Context ; Name : <b>in</b> Interfaces.C.Strings.Chars_Ptr ; Ty : <b>in</b> Yices_Type ) <b>return</b> Yices_Var_Decl ;
   <b>pragma</b> Import(C,Yices_Mk_Var_Decl,"yices_mk_var_decl") ;
   
   <FONT COLOR=green><EM>-- Return a variable declaration associated with the given name. </EM></FONT>
   <b>function</b> Yices_Get_Var_Decl_From_Name( Ctx : <b>in</b> Yices_Context ; Name : <b>in</b> Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Var_Decl ;
   <b>pragma</b> Import(C,Yices_Get_Var_Decl_From_Name,"yices_get_var_decl_from_name") ;
   
   <FONT COLOR=green><EM>-- Return the variable declaration object associated with the given name expression. </EM></FONT>
   <b>function</b> Yices_Get_Var_Decl( E : <b>in</b> Yices_Expr ) <b>return</b> Yices_Var_Decl ;
   <b>pragma</b> Import(C,Yices_Get_Var_Decl,"yices_get_var_decl") ;
   
   <FONT COLOR=green><EM>-- Return the name of a variable declaration. </EM></FONT>
   <b>function</b> Yices_Get_Var_Decl_Name( D : <b>in</b> Yices_Var_Decl ) <b>return</b> Interfaces.C.Strings.Chars_Ptr ;
   <b>pragma</b> Import(C,Yices_Get_Var_Decl_Name,"yices_get_var_decl_name") ;
   
   <FONT COLOR=green><EM>-- Return a name expression (instance) using the given variable declaration. </EM></FONT>
   <b>function</b> Yices_Mk_Var_From_Decl( Ctx : <b>in</b> Yices_Context ; D : <b>in</b> Yices_Var_Decl ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Var_From_Decl,"yices_mk_var_from_decl") ;
   
   <FONT COLOR=green><EM>-- Return a name expression (instance) using the given variable declaration. </EM></FONT>
   <b>function</b> Yices_Mk_Bool_Var_From_Decl( Ctx : <b>in</b> Yices_Context ; D : <b>in</b> Yices_Var_Decl ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bool_Var_From_Decl,"yices_mk_bool_var_from_decl") ;
   
   <FONT COLOR=green><EM>-- Return a name expression for the given variable name. </EM></FONT>
   <b>function</b> Yices_Mk_Bool_Var( Ctx : <b>in</b> Yices_Context ; Name : <b>in</b> Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bool_Var,"yices_mk_bool_var") ;
   
   <FONT COLOR=green><EM>-- Return a fresh boolean variable. </EM></FONT>
   <b>function</b> Yices_Mk_Fresh_Bool_Var( Ctx : <b>in</b> Yices_Context ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Fresh_Bool_Var,"yices_mk_fresh_bool_var") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing true.    </EM></FONT>
   <b>function</b> Yices_Mk_True( Ctx : <b>in</b> Yices_Context ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_True,"yices_mk_true") ;

   <FONT COLOR=green><EM>-- Return an expression representing false. </EM></FONT>
   <b>function</b> Yices_Mk_False( Ctx : <b>in</b> Yices_Context ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_False,"yices_mk_false") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing the or of the given arguments. </EM></FONT>
   <b>function</b> Yices_Mk_Or( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Int ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Or,"yices_mk_or") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing the and of the given arguments. </EM></FONT>
   <b>function</b> Yices_Mk_And( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Int ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_And,"yices_mk_and") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing (not a). </EM></FONT>
   <b>function</b> Yices_Mk_Not( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Not,"yices_mk_not") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 = a2. </EM></FONT>
   <b>function</b> Yices_Mk_Eq( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Eq,"yices_mk_eq") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 /= a2.</EM></FONT>
   <b>function</b> Yices_Mk_Diseq( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Diseq,"yices_mk_or") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing (if c t e).</EM></FONT>
   <b>function</b> Yices_Mk_Ite( Ctx : <b>in</b> Yices_Context ; C, T, E : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Ite,"yices_mk_ite") ;
   
   <FONT COLOR=green><EM>-- Return a function application term (f t1 ... tn). </EM></FONT>
   <b>function</b> Yices_Mk_App( Ctx : <b>in</b> Yices_Context ; F : <b>in</b> Yices_Expr ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_App,"yices_mk_app") ;   
   
   <FONT COLOR=green><EM>-- Build a function update term (update f (t1 ... tn) v). </EM></FONT>
   <b>function</b> Yices_Mk_Function_Update( Ctx : <b>in</b> Yices_Context ; F : <b>in</b> Yices_Expr ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ; V : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Function_Update,"yices_mk_function_update") ;
   
   <FONT COLOR=green><EM>-- Build a tuple term (tuple t1 ... tn). </EM></FONT>
   <b>function</b> Yices_Mk_Tuple_Literal( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Tuple_Literal,"yices_mk_tuple_literal") ;
      
   <FONT COLOR=green><EM>-- Return an expression representing the given integer. </EM></FONT>
   <b>function</b> Yices_Mk_Num( Ctx : <b>in</b> Yices_Context ; N : <b>in</b> Interfaces.C.Int ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Num,"yices_mk_num") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing the number provided in ASCII format. </EM></FONT>
   <b>function</b> Yices_Mk_Num_From_String( Ctx : <b>in</b> Yices_Context ; N : <b>in</b> Interfaces.C.Strings.Chars_Ptr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Num_From_String,"yices_mk_num_from_string") ;
   
   <FONT COLOR=green><EM>-- Construct a numerical expression form a GMP integer.</EM></FONT>
   <FONT COLOR=green><EM>--  yices_expr 	yices_mk_num_from_mpz (yices_context ctx, const mpz_t z)</EM></FONT>
   
   <FONT COLOR=green><EM>-- Construct a numerical expression form a GMP rational. </EM></FONT>
   <FONT COLOR=green><EM>--  yices_expr 	yices_mk_num_from_mpq (yices_context ctx, const mpq_t q)</EM></FONT>
   
   <FONT COLOR=green><EM>-- Return an expression representing args[0] + ... + args[n-1]. </EM></FONT>
   <b>function</b> Yices_Mk_Sum( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Sum,"yices_mk_sum") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing args[0] - ... - args[n-1]. </EM></FONT>
   <b>function</b> Yices_Mk_Sub( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Sub,"yices_mk_sub") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing args[0] * ... * args[n-1]. </EM></FONT>
   <b>function</b> Yices_Mk_Mul( Ctx : <b>in</b> Yices_Context ; Args : <b>in</b> Yices_Expr_Array ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Mul,"yices_mk_mul") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 &lt; a2. </EM></FONT>
   <b>function</b> Yices_Mk_Lt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Lt,"yices_mk_lt") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 &lt;= a2. </EM></FONT>
   <b>function</b> Yices_Mk_Le( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Le,"yices_mk_le") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 &gt; a2. </EM></FONT>
   <b>function</b> Yices_Mk_Gt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Gt,"yices_mk_gt") ;
   
   <FONT COLOR=green><EM>-- Return an expression representing a1 &gt;= a2. </EM></FONT>
   <b>function</b> Yices_Mk_Ge( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Ge,"yices_mk_ge") ;
   
   <FONT COLOR=green><EM>-- Create a bit vector constant of size bits and of the given value. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Constant( Ctx : <b>in</b> Yices_Context ; Size : <b>in</b> Interfaces.C.Unsigned ; Value : <b>in</b> Interfaces.C.Unsigned_Long ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Constant,"yices_mk_bv_constant") ;
   
   <FONT COLOR=green><EM>-- Create a bit vector constant from an array. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Constant_From_Array( Ctx : <b>in</b> Yices_Context ; Size : <b>in</b> Interfaces.C.Unsigned ; Bv : <b>in</b> Bv_Array ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Constant_From_Array,"yices_mk_bv_constant_from_array") ;
   
   <FONT COLOR=green><EM>-- Bitvector addition. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Add( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Add,"yices_mk_bv_add") ;
   
   <FONT COLOR=green><EM>-- Bitvector subtraction. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Sub( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Sub,"yices_mk_bv_sub") ;
   
   <FONT COLOR=green><EM>-- Bitvector multiplication. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Mul( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Mul,"yices_mk_bv_mul") ;
   
   <FONT COLOR=green><EM>-- Bitvector opposite. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Minus( Ctx : <b>in</b> Yices_Context ; A1 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Minus,"yices_mk_bv_minus") ;
   
   <FONT COLOR=green><EM>-- Bitwise and. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_And( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_And,"yices_mk_bv_and") ;
   
   <FONT COLOR=green><EM>-- Bitwise or. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Or( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Or,"yices_mk_bv_or") ;
   
   <FONT COLOR=green><EM>-- Bitwise exclusive or. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Xor( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Xor,"yices_mk_bv_xor") ;
   
   <FONT COLOR=green><EM>-- Bitwise negation. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Not( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Not,"yices_mk_bv_not") ;
   
   <FONT COLOR=green><EM>-- Bitvector concatenation. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Concat( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Concat,"yices_mk_bv_concat");
   
   <FONT COLOR=green><EM>-- Bitvector extraction. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Extract( Ctx : <b>in</b> Yices_Context ; E,B : <b>in</b> Interfaces.C.Unsigned ; A : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Extract,"yices_mk_bv_extract") ;
   
   <FONT COLOR=green><EM>-- Sign extension. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Sign_Extend( Ctx : <b>in</b> Yices_Context ; E,B : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Sign_Extend,"yices_mk_bv_sign_extend") ;
   
   <FONT COLOR=green><EM>-- Left shift by n bits, padding with zeros. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Shift_Left0( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Yices_Expr ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Shift_Left0,"yices_mk_bv_shift_left0") ;
   
   <FONT COLOR=green><EM>-- Left shift by n bits, padding with ones. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Shift_Left1( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Yices_Expr ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Shift_Left1,"yices_mk_bv_shift_left1") ;
   
   <FONT COLOR=green><EM>-- Right shift by n bits, padding with zeros. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Shift_Right0( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Yices_Expr ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Shift_Right0,"yices_mk_bv_shift_right0") ;
   
   <FONT COLOR=green><EM>-- Right shift by n bits, padding with ones. </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Shift_Right1( Ctx : <b>in</b> Yices_Context ; A : <b>in</b> Yices_Expr ; N : <b>in</b> Interfaces.C.Unsigned ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Shift_Right1,"yices_mk_bv_shift_right1") ; 
   
   <FONT COLOR=green><EM>-- Unsigned comparison: (a1 &lt; a2).</EM></FONT>
   <b>function</b> Yices_Mk_Bv_Lt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Lt,"yices_mk_bv_lt") ;
   
   <FONT COLOR=green><EM>-- Unsigned comparison: (a1 &lt;= a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Le( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Le,"yices_mk_bv_le") ;
   
   <FONT COLOR=green><EM>-- Unsigned comparison: (a1 &gt; a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Gt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Gt,"yices_mk_bv_gt") ;
   
   <FONT COLOR=green><EM>-- Unsigned comparison: (a1 &gt;= a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Ge( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Ge,"yices_mk_bv_ge") ;
   
   <FONT COLOR=green><EM>-- Signed comparison: (a1 &lt; a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Slt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Slt,"yices_mk_bv_slt") ;
   
   <FONT COLOR=green><EM>-- Signed comparison: (a1 &lt;= a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Sle( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Sle,"yices_mk_bv_sle") ;
   
   <FONT COLOR=green><EM>-- Signed comparison: (a1 &gt; a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Sgt( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Sgt,"yices_mk_bv_sle") ;
   
   <FONT COLOR=green><EM>-- Signed comparison: (a1 &gt;= a2). </EM></FONT>
   <b>function</b> Yices_Mk_Bv_Sge( Ctx : <b>in</b> Yices_Context ; A1, A2 : <b>in</b> Yices_Expr ) <b>return</b> Yices_Expr ;
   <b>pragma</b> Import(C,Yices_Mk_Bv_Sge,"yices_mk_bv_sle") ;
   
   <FONT COLOR=green><EM>-- Pretty print the given expression in the standard output. </EM></FONT>
   <b>procedure</b> Yices_Pp_Expr( E : <b>in</b> Yices_Expr ) ;
   <b>pragma</b> Import(C,Yices_Pp_Expr,"yices_pp_expr") ;
      
<b>end</b> Yices ;
</PRE></BODY></HTML>
